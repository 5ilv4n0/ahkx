/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.19_01 from the
 * contents of GUITest.xs. Do not edit this file, edit GUITest.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "GUITest.xs"
/* X11::GUITest ($Id: GUITest.xs,v 1.53 2006/04/28 17:50:33 ctrondlp Exp $)
 *  
 * Copyright (c) 2003-2006  Dennis K. Paulsen, All Rights Reserved.
 * Email: ctrondlp@cpan.org
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
#ifdef __cplusplus
extern "C" {
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#ifdef __cplusplus
}
#endif

/* Added for pre-v5.6.x Perl */
#ifndef newSVuv
#define newSVuv newSViv
#endif

#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <X11/keysym.h>
#include <X11/extensions/XTest.h>
#include "GUITest.h"

/* File Level Variables */
static Display *TheXDisplay = NULL;
static int TheScreen = 0;
static WindowTable ChildWindows = {0};
static ULONG EventSendDelay = DEF_EVENT_SEND_DELAY;
static ULONG KeySendDelay = DEF_KEY_SEND_DELAY;
static int (*OldErrorHandler)(Display *, XErrorEvent *) = NULL;

/* Non Exported Utility Functions: */

/* Function: IgnoreBadWindow
 * Description: User defined error handler callback for X event errors.
 */
static int IgnoreBadWindow(Display *display, XErrorEvent *error)
{
	/* Ignore bad window errors here, handle elsewhere */
	if (error->error_code != BadWindow) {
		assert(NULL != OldErrorHandler);
		(*OldErrorHandler)(display, error);
	}
	/* Note: Return is ignored */
	return(0);
}

/* Function: SetupXDisplay
 * Description: Sets up our connection to the X server's display
 */
static void SetupXDisplay(void)
{
	int eventnum = 0, errornum = 0,
		majornum = 0, minornum = 0;

	/* Get Display Pointer */
	TheXDisplay = XOpenDisplay(NULL);
	if (TheXDisplay == NULL) {
		croak("X11::GUITest - This program is designed to run in X Windows!\n");
	}

	/* Ensure the XTest extension is available */
	if (!XTestQueryExtension(TheXDisplay, &eventnum, &errornum, 
							 &majornum, &minornum)) {
		croak("X11::GUITest - XServer %s doesn't support the XTest extensions!\n",
			  DisplayString(TheXDisplay));
	}

	TheScreen = DefaultScreen(TheXDisplay);

	/* Discard current events in queue. */	
	XSync(TheXDisplay, True);
}

/* Function: CloseXDisplay
 * Description: Closes our connection to the X server's display
 */
static void CloseXDisplay(void)
{
	if (TheXDisplay) {
		XSync(TheXDisplay, False);
		XCloseDisplay(TheXDisplay);
		TheXDisplay = NULL;
	}
}

/* Function: IsNumber
 * Description: Determines if the specified string represents a
 *              number.
 */
static BOOL IsNumber(const char *str)
{
	size_t x = 0, len = 0;

	assert(str != NULL);

	len = strlen(str);
	for (x = 0; x < len; x++) {
		if (!isdigit(str[x])) {
			return(FALSE);
		}
	}
	return(TRUE);
}

/* Function: GetKeySym
 * Description: Given a regular(i.e., a) or special(i.e., Tab) key name,
 *              this function obtains the appropriate keysym by first
 *              checking the XStringToKeysym (case sensitive) library
 *        		function.  If the key is not recognized by that function,
 *				an internal table to this function is utilized for the
 *				lookup (case insensitive).
 * Note: Returns TRUE (non-zero) on success, FALSE (zero) on failure.  Also,
 *       on success, sym gets set to the appropriate keysym. On failure, sym
 * 		 gets set to NoSymbol.
 */
static BOOL GetKeySym(const char *name, KeySym *sym)
{
	static const KeyNameSymTable kns_table[] = { /* {Name, Sym}, */
		{"BAC", XK_BackSpace},		{"BS", XK_BackSpace},		{"BKS", XK_BackSpace},
 		{"BRE", XK_Break},			{"CAN", XK_Cancel}, 		{"CAP", XK_Caps_Lock},
		{"DEL", XK_Delete},			{"DOW", XK_Down},			{"END", XK_End},
		{"ENT", XK_Return},			{"ESC", XK_Escape},			{"HEL", XK_Help},
		{"HOM", XK_Home},			{"INS", XK_Insert},			{"LEF", XK_Left},
		{"NUM", XK_Num_Lock},		{"PGD", XK_Next},			{"PGU", XK_Prior},
		{"PRT", XK_Print},			{"RIG", XK_Right},			{"SCR", XK_Scroll_Lock},
		{"TAB", XK_Tab},			{"UP", XK_Up},				{"F1", XK_F1},
		{"F2", XK_F2},				{"F3", XK_F3},				{"F4", XK_F4},
		{"F5", XK_F5},				{"F6", XK_F6},				{"F7", XK_F7},
		{"F8", XK_F8},				{"F9", XK_F9},				{"F10", XK_F10},
		{"F11", XK_F11},			{"F12", XK_F12},			{"SPC", XK_space},
		{"SPA", XK_space},			{"LSK", XK_Super_L}, 		{"RSK", XK_Super_R},
		{"MNU", XK_Menu},			{"~", XK_asciitilde},		{"_", XK_underscore},
		{"[", XK_bracketleft},		{"]", XK_bracketright},		{"!", XK_exclam},
		{"\"", XK_quotedbl}, 		{"#", XK_numbersign},		{"$", XK_dollar},
		{"%", XK_percent},			{"&", XK_ampersand}, 		{"'", XK_quoteright},
		{"*", XK_asterisk},			{"+", XK_plus},				{",", XK_comma},
		{"-", XK_minus},			{".", XK_period}, 			{"?", XK_question},
		{"<", XK_less},				{">", XK_greater},			{"=", XK_equal},
		{"@", XK_at},				{":", XK_colon},			{";", XK_semicolon},
		{"\\", XK_backslash}, 		{"`", XK_grave},			{"{", XK_braceleft},
		{"}", XK_braceright},		{"|", XK_bar},				{"^", XK_asciicircum},
		{"(", XK_parenleft},		{")", XK_parenright}, 		{" ", XK_space},
		{"/", XK_slash},			{"\t", XK_Tab},				{"\n", XK_Return},
		{"LSH", XK_Shift_L},		{"RSH", XK_Shift_R},		{"LCT", XK_Control_L},
		{"RCT", XK_Control_R},		{"LAL", XK_Alt_L},			{"RAL", XK_Alt_R},
                {"LMA", XK_Meta_L},		{"RMA", XK_Meta_R}, 
	};
	size_t x = 0;

	assert(name != NULL);
	assert(sym != NULL);

	/* See if we can obtain the KeySym without looking at table. 
	 * Note: XStringToKeysym("space") would return KeySym
	 * XK_space... Case sensitive. */
	*sym = XStringToKeysym(name);
	if (*sym != NoSymbol) {
		/* Got It */
		return(TRUE);
	}
	/* Do case insensitive search for specified name to obtain the KeySym from table */
	for (x = 0; x < (sizeof(kns_table) / sizeof(KeyNameSymTable)); x++) {
		if (strcasecmp(kns_table[x].Name, name) == 0) {
			/* Found It */
			*sym = kns_table[x].Sym;
			return(TRUE);
		}
	}
	/* Not Found */	
	*sym = NoSymbol;
	return(FALSE);
}

/* Function: GetRegKeySym
 * Description: Given a regular key name as a single character(i.e., a), this
 *				function obtains the appropriate keysym by calling GetKeySym(). 
 * Note: Returns TRUE (non-zero) on success, FALSE (zero) on failure.  Also,
 *       on success, sym gets set to the appropriate keysym. On failure, sym
 * 		 will get set to NoSymbol.
 */
static BOOL GetRegKeySym(const char name, KeySym *sym)
{
	#define MAX_REG_KEY 2
	static char key[MAX_REG_KEY] = "";
	
	key[0] = name;
	key[1] = NUL;

	return( GetKeySym(key, sym) );
}

/* Function: GetKeycodeFromKeysym
 * Description: Wrapper around XKeysymToKeycode.  Supports compile-time
 *              workarounds, etc.
 */
static KeyCode GetKeycodeFromKeysym(Display *display, KeySym keysym)
{
 	KeyCode kc = XKeysymToKeycode(display, keysym);
#ifdef X11_GUITEST_ALT_L_FALLBACK_META_L
	/* Xvfb lacks XK_Alt_L; fall back to XK_Meta_L */
 	if (kc == 0 && keysym == XK_Alt_L) {
 		kc = XKeysymToKeycode(display, XK_Meta_L);
	}
#endif
	return(kc);
}

/* Function: PressKeyImp
 * Description: Presses the key for the specified keysym.  Lower-level
 * 				implementation.
 * Note: Returns TRUE (non-zero) on success, FALSE (zero) on failure.
 */
static BOOL PressKeyImp(KeySym sym)
{
	KeyCode kc = 0;
	BOOL retval = 0;

	kc = GetKeycodeFromKeysym(TheXDisplay, sym);
	if (kc == 0) {
		return(FALSE);
	}

	retval = (BOOL)XTestFakeKeyEvent(TheXDisplay, kc, True, EventSendDelay);
	
	XFlush(TheXDisplay);
	return(retval);
}

/* Function: ReleaseKeyImp 
 * Description: Releases the key for the specified keysym.  Lower-level
 *			 	implementation.
 * Note: Returns TRUE (non-zero) on success, FALSE (zero) on failure.
 */
static BOOL ReleaseKeyImp(KeySym sym)
{
	KeyCode kc = 0;
	BOOL retval = 0;
	
	kc = GetKeycodeFromKeysym(TheXDisplay, sym);
	if (kc == 0) {
		return(FALSE);
	}

	retval = (BOOL)XTestFakeKeyEvent(TheXDisplay, kc, False, EventSendDelay);

	XFlush(TheXDisplay);
	return(retval);
}

/* Function: PressReleaseKeyImp
 * Description: Presses and releases the key for the specified keysym.
 * 				Also implements key send delay.  Lower-level implementation.
 * Note: Returns TRUE (non-zero) on success, FALSE (zero) on failure.
 */
static BOOL PressReleaseKeyImp(KeySym sym)
{
	if (!PressKeyImp(sym)) {
		return(FALSE);
	}
	if (!ReleaseKeyImp(sym)) {
		return(FALSE);
	}
	/* Possibly wait between(after) keystrokes */ 
	if (KeySendDelay > 0) {
		/* usleep(500 * 1000) = ~500ms */
		usleep(KeySendDelay * 1000);
	}
	return(TRUE);
}

/* Function: IsShiftNeeded
 * Description: Determines if the specified keysym needs the shift
 *				modifier. 
 * Note: Returns TRUE (non-zero) on success, FALSE (zero) on failure.
 */
static BOOL IsShiftNeeded(KeySym sym)
{
	KeySym ksl = 0, ksu = 0, *kss = NULL;
	KeyCode kc = 0;
	int syms = 0;
	BOOL needed = FALSE;
	
	kc = GetKeycodeFromKeysym(TheXDisplay, sym);
	if (!kc) {
		return(FALSE);
	}

	/* kc(grave) = kss(grave, asciitilde, ) */	
	kss = XGetKeyboardMapping(TheXDisplay, kc, 1, &syms);

	XConvertCase(sym, &ksl, &ksu);

	if (sym == kss[0] && (sym == ksl && sym == ksu)) {
		/* Not subject to case conversion */
		needed = FALSE;
	} else if (sym == ksl && sym != ksu) {
		/* Shift not needed */
		needed = FALSE;
	} else {
		/* Shift needed */
		needed = TRUE;
	}

	XFree(kss);
	return(needed);
}

/* Function: ProcessBraceSet
 * Description: Takes a brace set such as: {Tab}, {Tab 3},
 *				{Tab Tab a b c}, {PAUSE 500}, {PAUSE 500 Tab}, etc.
 *              and breaks it into components, then proceeds to press 
 *				the appropriate keys or perform the	special functionality
 *				requested (i.e., PAUSE).  Numeric elements are used in the
 *				special functionality or simply to ensure the previous key
 *				element gets pressed the specified number of times.
 * Note: Returns TRUE (non-zero) on success, FALSE (zero) on failure.
 */
static BOOL ProcessBraceSet(const char *braceset, size_t *len)
{
	enum {NONE, PAUSE, KEY}; /* Various Functionalities */
	int cmd = NONE, count = 0, i = 0;
	BOOL needshift = FALSE;
	char *buffer = NULL, *endbrc = NULL, *token = NULL;
	KeySym sym = 0;

	assert(braceset != NULL);
	assert(len != NULL);

	/* Fail if there isn't a valid brace set */
	if (*braceset != '{' || !strchr(braceset, '}')) {
		return(FALSE);
	}

	/* Create backup buffer because we are using strtok */
	buffer = (char *)safemalloc(strlen(braceset));
	if (buffer == NULL) {
		return(FALSE);
	}
	/* Ignore beginning { char */
	strcpy(buffer, &braceset[1]);

	/* Get brace end in buffer */
	endbrc = strchr(buffer, '}');
	if (endbrc == NULL) {
		safefree(buffer);
		return(FALSE);
	}
	/* If we have a quoted }, move over one character */
	if (endbrc[1] == '}') {
		endbrc++;
	}
	/* Terminate brace set */
	*endbrc = NUL;

	/* Store brace set length for calling function.  Include
	 * 2 for {} we ignored */
	*len = strlen(buffer) + 2;
	
	/* Work on the space delimited items in the buffer. */
	if ( !(token = strtok(buffer, " ")) ) {
		safefree(buffer);
		return(FALSE);
	}
	
	do { /* } while ( (token = strtok(NULL, " ")) ); */
		count = 0;
		if (IsNumber(token)) {
			/* Yes, a number, so convert it for key depresses or for command specific use */
			if ( (count = atoi(token)) <= 0 ) {
				safefree(buffer);
				return(FALSE);
			}	
		} else {
			cmd = NONE;
			/* Special functionality? */
			if (strcasecmp(token, "PAUSE") == 0) {
				/* Yes, PAUSE, so continue on to get the duration count */
				cmd = PAUSE;
				continue;	
			} else {
				/* No, just a key, so get symbol */
				cmd = KEY;
				if (!GetKeySym(token, &sym)) {
					safefree(buffer);
					return(FALSE);
				}
				needshift = IsShiftNeeded(sym);
				if (needshift) {
					PressKeyImp(XK_Shift_L);
				}
				/* Press key */
				if (!PressReleaseKeyImp(sym)) {
					if (needshift) {
						ReleaseKeyImp(XK_Shift_L);
					}
					safefree(buffer);
					return(FALSE);
				}		
				if (needshift) {
					ReleaseKeyImp(XK_Shift_L);
				}
			}
		}
		/* Handle commands that can use a specified count */
		if (count > 0) {
			switch (cmd) {
			case PAUSE:
				/* usleep(500 * 1000) = 500ms */
				usleep(count * 1000);
				break;
			case KEY:
				/* Repeat the last key if needed.  Start at iteration 2
				 * because we have already depressed key once up above */
				/* Use shift if needed */
				if (needshift) {
					PressKeyImp(XK_Shift_L);
				}
				for (i = 2; i <= count; i++) {
					/* Use sym that was already stored from above */
					if (!PressReleaseKeyImp(sym)) {
						if (needshift) {
							ReleaseKeyImp(XK_Shift_L);
						}
						safefree(buffer);
						return(FALSE);
					}
				}
				if (needshift) {
					ReleaseKeyImp(XK_Shift_L);
				}
				break;
			default:
				/* Fail, we have a count, but an unknown command! */
				safefree(buffer);
				return(FALSE);
			}; /* switch (cmd) { */
		} /* if (count > 0) { */
	} while ( (token = strtok(NULL, " ")) );	
	
	safefree(buffer);
	return(TRUE);
}
 
/* Function: SendKeysImp
 * Description: Underlying implementation of the SendKeys routine.  Read
 * 				the SendKeys documentation below for some specifics.
 * Note: Returns TRUE (non-zero) on success, FALSE (zero) on failure.
 *       Also, if you add special character handling below, also ensure
 * 		 the QuoteStringForSendKeys function is accurate in GUITest.pm.
 */
static BOOL SendKeysImp(const char *keys)
{
	KeySym sym = 0;
	size_t keyslen = 0, bracelen = 0;
	size_t x = 0;
	BOOL retval = FALSE, shift = FALSE, ctrl = FALSE, 
		 alt = FALSE, meta = FALSE, modlock = FALSE, needshift = FALSE;

	assert(keys != NULL);

	keyslen = strlen(keys);
	for (x = 0; x < keyslen; x++) {
		switch (keys[x]) {
		/* Brace Set? of quoted/special characters (i.e. {{}, {TAB}, {F1 F2}, {PAUSE 200}) */
		case '{':
			if (!ProcessBraceSet(&keys[x], &bracelen)) {
				return(FALSE);
			}
			/* Skip past the brace set, Note: - 1 because we are at { already */
			x += (bracelen - 1);
			continue;
		/* Modifiers? */
		case '~': retval = PressReleaseKeyImp(XK_Return); break;
		case '+': /* Shift */ 
			retval = PressKeyImp(XK_Shift_L);
			shift = TRUE;
			break;
		case '^':  /* Control */
			retval = PressKeyImp(XK_Control_L);
			ctrl = TRUE;
			break;
		case '%': /* Alt */ 
			retval = PressKeyImp(XK_Alt_L);
			alt = TRUE; 
			break;
		case '#': /* Meta */
			retval = PressKeyImp(XK_Meta_L);
			meta = TRUE; 
			break;
		case '(': modlock = TRUE; break;
		case ')': modlock = FALSE; break;
		/* Regular Key? (a, b, c, 1, 2, 3, _, *, %), etc. */
		default:
			if (!GetRegKeySym(keys[x], &sym)) {
				return(FALSE);
			}
			/* Use shift if needed */
			needshift = IsShiftNeeded(sym);
			if (!shift && needshift) {
				PressKeyImp(XK_Shift_L);
			} 
			retval = PressReleaseKeyImp(sym);
			/* Release shift if needed */	
			if (!shift && needshift) {
				ReleaseKeyImp(XK_Shift_L);
			} 
			break;
		}; /* switch (keys[x]) { */
		/* If modlock coming up next, go on to process it */
		if (keys[x + 1] == '(') {
			continue;
		}
		/* Ensure modifiers are clear when needed */
		if (!modlock && shift) {
			ReleaseKeyImp(XK_Shift_L); 
			shift = FALSE; 		
		}
		if (!modlock && ctrl) { 
			ReleaseKeyImp(XK_Control_L); 
			ctrl = FALSE;
		}	
		if (!modlock && alt) {
			ReleaseKeyImp(XK_Alt_L); 
			alt = FALSE;
		}
		if (!modlock && meta) {
			ReleaseKeyImp(XK_Meta_L); 
			meta = FALSE;
		}
		if (!retval) {
			return(FALSE);
		}
	} /* for (x =  0; x < keyslen; x++) { */

	return(TRUE);
}

/* Function: IsWindowImp
 * Description: Underlying implementation of the IsWindow routine.  Read
 *				the IsWindow documentation below for some specifics.
 * Note: Returns non-zero for true, zero for false.
 */
static BOOL IsWindowImp(Window win)
{
	XWindowAttributes wattrs = {0};
	BOOL retval;

	OldErrorHandler = XSetErrorHandler(IgnoreBadWindow);
	retval = (BOOL)(XGetWindowAttributes(TheXDisplay, win, &wattrs) != 0);
	XSetErrorHandler(OldErrorHandler);
	return(retval);
}

/* Function: AddChildWindow
 * Description: Adds the specified window Id to the internally managed
 *				table of available window Ids.  Also handles the memory
 *				allocation for this table.
 * Note: Returns TRUE (non-zero) on success, FALSE (zero) on failure.
 */
static BOOL AddChildWindow(Window win)
{
	enum {INIT = 1, GROW = 2}; /* Memory Allocation */

	if (!win) {
		return(FALSE);
	}

	if (ChildWindows.Ids == NULL) {
		/* Initialize */
		ChildWindows.Ids = (Window *)safemalloc(INIT * sizeof(Window));
		if (ChildWindows.Ids == NULL) {
			return(FALSE);
		}
		ChildWindows.Max = INIT;
		ChildWindows.NVals = 0;
	} else if (ChildWindows.NVals >= ChildWindows.Max) {
		/* Grow */
		Window *TempIds = NULL;
		TempIds = (Window *)saferealloc(ChildWindows.Ids, 
						(GROW * ChildWindows.Max) * sizeof(Window));
		if (TempIds == NULL) {
			return(FALSE);
		}
		ChildWindows.Max *= GROW;
		ChildWindows.Ids = TempIds;
	}
	/* Place the new window Id in */
	ChildWindows.Ids[ChildWindows.NVals] = win;
	ChildWindows.NVals++;

	return(TRUE);
}

/* Function: ClearChildWindows
 * Description: Clears the table of window Ids.  Memory allocated
 *				in AddChildWindow is not freed here, because
 *				we'll probably want to take advantage of it again. 
 * Note: No return value.
 */
static void ClearChildWindows(void)
{
	if (ChildWindows.Ids) {
		memset(ChildWindows.Ids, 0, ChildWindows.Max * sizeof(Window));
	}
	ChildWindows.NVals = 0;
}

/* Function: FreeChildWindows
 * Description: Deallocates the memory of the window Id table
 * 				that was allocated through AddChildWindow.  This
 *				should be called on exit. 
 * Note: No return value.
 */
static void FreeChildWindows(void)
{
	if (ChildWindows.Ids) {
		safefree(ChildWindows.Ids);
		ChildWindows.Ids = NULL;
	}
	ChildWindows.NVals = 0;
	ChildWindows.Max = 0;
}

/* Function: EnumChildWindowsAux
 * Description: Obtains the list of window Ids
 * Note: Returns value indicating success of obtaining
 *       windows.
 */
static BOOL EnumChildWindowsAux(Window win)
{
   	Window root = 0, parent = 0, *children = NULL;
   	UINT childcount = 0;
	UINT i = 0;

	/* get list of child windows */
	if (XQueryTree(TheXDisplay, win, &root, &parent, &children, 
				   &childcount)) {
	   	for (i = 0; i < childcount; i++) {
			/* Add Child */
			AddChildWindow(children[i]);
			/* Look for its descendents */
	   		if (!EnumChildWindowsAux(children[i])) {
				XFree(children);
				return FALSE;
			}
   		}
   		if (children) {
       		XFree(children);
   		}
		return TRUE;
	} else {
		return FALSE;
	}
}

/* Function: EnumChildWindows
 * Description: Calls utility function to obtain list of window
 *              Ids.  Helps handle window transitions.
 * Note: Returns nothing.
 */
static void EnumChildWindows(Window win)
{
	BOOL success = 0;
	
	for (;;) {
		if (!IsWindowImp(win)) {
			return;
		}

		OldErrorHandler = XSetErrorHandler(IgnoreBadWindow);
		success = EnumChildWindowsAux(win);
		XSetErrorHandler(OldErrorHandler);
		if (success) {
			return;
		}
		/* Failure: try again, in 1/2 second. */
		ClearChildWindows();
		usleep(500000); /* 500000 = 1/2 second */
	}
}

#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#line 720 "GUITest.c"

XS(XS_X11__GUITest_InitGUITest); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_InitGUITest)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::InitGUITest", "");
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 712 "GUITest.xs"
	/* Things to do on initialization */
	SetupXDisplay();
	XTestGrabControl(TheXDisplay, True);
	XSRETURN(0);
#line 741 "GUITest.c"
	PUTBACK;
	return;
    }
}


XS(XS_X11__GUITest_DeInitGUITest); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_DeInitGUITest)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::DeInitGUITest", "");
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 720 "GUITest.xs"
	/* Things to do on deinitialization */
	CloseXDisplay();
	FreeChildWindows();
	XSRETURN(0);
#line 767 "GUITest.c"
	PUTBACK;
	return;
    }
}


XS(XS_X11__GUITest_DefaultScreen); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_DefaultScreen)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::DefaultScreen", "");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	int	RETVAL;
	dXSTARG;
#line 740 "GUITest.xs"
	RETVAL = TheScreen;
#line 790 "GUITest.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_X11__GUITest_ScreenCount); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_ScreenCount)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::ScreenCount", "");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	int	RETVAL;
	dXSTARG;
#line 758 "GUITest.xs"
	RETVAL = ScreenCount(TheXDisplay);
#line 813 "GUITest.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_X11__GUITest_SetEventSendDelay); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_SetEventSendDelay)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::SetEventSendDelay", "delay");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	ULONG	delay = (ULONG)SvUV(ST(0));
	ULONG	RETVAL;
	dXSTARG;
#line 782 "GUITest.xs"
	/* Returning old delay amount */
	RETVAL = EventSendDelay;
	EventSendDelay = delay;
#line 839 "GUITest.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_X11__GUITest_GetEventSendDelay); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_GetEventSendDelay)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::GetEventSendDelay", "");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	ULONG	RETVAL;
	dXSTARG;
#line 802 "GUITest.xs"
	RETVAL = EventSendDelay;
#line 862 "GUITest.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_X11__GUITest_SetKeySendDelay); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_SetKeySendDelay)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::SetKeySendDelay", "delay");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	ULONG	delay = (ULONG)SvUV(ST(0));
	ULONG	RETVAL;
	dXSTARG;
#line 823 "GUITest.xs"
	/* Returning old delay amount */
	RETVAL = KeySendDelay;
	KeySendDelay = delay;
#line 888 "GUITest.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_X11__GUITest_GetKeySendDelay); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_GetKeySendDelay)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::GetKeySendDelay", "");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	ULONG	RETVAL;
	dXSTARG;
#line 843 "GUITest.xs"
	RETVAL = KeySendDelay;
#line 911 "GUITest.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_X11__GUITest_GetWindowName); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_GetWindowName)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::GetWindowName", "win");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Window	win = (Window)SvUV(ST(0));
#line 866 "GUITest.xs"
	char *name = NULL;
#line 933 "GUITest.c"
	SV *	RETVAL;
#line 868 "GUITest.xs"
	if (IsWindowImp(win) && XFetchName(TheXDisplay, win, &name)) {
		RETVAL = newSVpv(name, strlen(name));
		XFree(name);
	} else {
		RETVAL = &PL_sv_undef; 
	}
#line 942 "GUITest.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_X11__GUITest_SetWindowName); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_SetWindowName)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::SetWindowName", "win, name");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Window	win = (Window)SvUV(ST(0));
	char *	name = (char *)SvPV_nolen(ST(1));
#line 895 "GUITest.xs"
	XTextProperty textprop = {0};
	size_t namelen = 0;
	Atom utf8_string = 0;
	Atom net_wm_name = 0;
	Atom net_wm_icon_name = 0;
#line 970 "GUITest.c"
	BOOL	RETVAL;
	dXSTARG;
#line 901 "GUITest.xs"
	RETVAL = FALSE;
	if (IsWindowImp(win)) {
		if (XStringListToTextProperty(&name, 1, &textprop)) {
			XSetWMName(TheXDisplay, win, &textprop);
			XSetWMIconName(TheXDisplay, win, &textprop);
			XFree(textprop.value);
			RETVAL = TRUE;
		}
		/* These UTF8 window name properties can be the properties
		 * that get displayed, so we set them too. */
		utf8_string = XInternAtom(TheXDisplay, "UTF8_STRING", True);
		if (utf8_string != None) {
			net_wm_name = XInternAtom(TheXDisplay, "_NET_WM_NAME", True);
			net_wm_icon_name = XInternAtom(TheXDisplay, "_NET_WM_ICON_NAME", True);
			if (net_wm_name != None && net_wm_icon_name != None) {
				namelen = strlen(name);
				XChangeProperty(TheXDisplay, win, net_wm_name, utf8_string, 8,
								PropModeReplace, (unsigned char *)name, namelen);
				XChangeProperty(TheXDisplay, win, net_wm_icon_name, utf8_string, 8,
								PropModeReplace, (unsigned char *)name, namelen);
			}
		}
	}	
#line 997 "GUITest.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_X11__GUITest_GetRootWindow); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_GetRootWindow)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 0 || items > 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::GetRootWindow", "scr_num = NO_INIT");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	int	scr_num;
	Window	RETVAL;
	dXSTARG;

	if (items >= 1) {
	    scr_num = (int)SvIV(ST(0));
	}
#line 944 "GUITest.xs"
	if (0 == items)
		scr_num = TheScreen;
	if (scr_num >= 0 && scr_num < ScreenCount(TheXDisplay))
		RETVAL = RootWindow(TheXDisplay, scr_num);
	else
		RETVAL = None;
#line 1030 "GUITest.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_X11__GUITest_GetChildWindows); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_GetChildWindows)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::GetChildWindows", "win");
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Window	win = (Window)SvUV(ST(0));
#line 971 "GUITest.xs"
	UINT i = 0;
#line 1054 "GUITest.c"
#line 973 "GUITest.xs"
	EnumChildWindows(win);
	EXTEND(SP, (int)ChildWindows.NVals);
	for (i = 0; i < ChildWindows.NVals; i++) {
		PUSHs(sv_2mortal(newSVuv((UV)ChildWindows.Ids[i])));
	}
	ClearChildWindows();
	XSRETURN(i);
#line 1063 "GUITest.c"
	PUTBACK;
	return;
    }
}


XS(XS_X11__GUITest_MoveMouseAbs); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_MoveMouseAbs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::MoveMouseAbs", "x, y, scr_num = NO_INIT");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	int	x = (int)SvIV(ST(0));
	int	y = (int)SvIV(ST(1));
	int	scr_num;
	BOOL	RETVAL;
	dXSTARG;

	if (items >= 3) {
	    scr_num = (int)SvIV(ST(2));
	}
#line 1001 "GUITest.xs"
	if (items < 3)
		scr_num = TheScreen;
	if (scr_num >= 0 && scr_num < ScreenCount(TheXDisplay)) {
#ifndef X11_GUITEST_USING_XINERAMA
		RETVAL = (BOOL)XTestFakeMotionEvent(TheXDisplay, scr_num, x, y,
						    EventSendDelay);
		XFlush(TheXDisplay);
#else
		ULONG tmp;

		    /* I decided not to set our error handler, since the
		       window must exist. */
		XWarpPointer(TheXDisplay, None,
			     RootWindow(TheXDisplay, scr_num),
			     0, 0, 0, 0,
			     x, y);
		XSync(TheXDisplay, False);
		tmp = EventSendDelay / (ULONG) 1000;
		while ((ULONG) 0 != tmp)
			tmp = (ULONG) sleep((int) tmp);
		tmp = EventSendDelay % (ULONG) 1000;
		usleep(1000 * tmp);
#endif
		RETVAL = (BOOL) 1;
	} else {
		RETVAL = (BOOL) 0;
	}
#line 1119 "GUITest.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_X11__GUITest_GetMousePos); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_GetMousePos)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::GetMousePos", "");
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 1048 "GUITest.xs"
	Window root = 0, child = 0;
	int root_x = 0, root_y = 0;
	int win_x = 0, win_y = 0, scr_num = 0;
	UINT mask = 0;
#line 1145 "GUITest.c"
#line 1053 "GUITest.xs"
		/* We do not bother to set our error handler because the
		   window given has to exist. */
	XQueryPointer(TheXDisplay, RootWindow(TheXDisplay, TheScreen),
		      &root, &child, &root_x, &root_y, &win_x, &win_y, &mask);
	EXTEND(SP, 3);
	PUSHs( sv_2mortal(newSViv((IV)root_x)) );
	PUSHs( sv_2mortal(newSViv((IV)root_y)) );
	for (scr_num = ScreenCount(TheXDisplay) - 1; scr_num >= 0 ; --scr_num)
	{
		if (root == RootWindow(TheXDisplay, scr_num)) {
			break;
		}
		assert(0 != scr_num);
		/* There is something really wrong with the Xlib data
		   structures, if this "assert" fails. */
	}
	PUSHs( sv_2mortal(newSViv((IV)scr_num)) );
	XSRETURN(3);
#line 1165 "GUITest.c"
	PUTBACK;
	return;
    }
}


XS(XS_X11__GUITest_PressMouseButton); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_PressMouseButton)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::PressMouseButton", "button");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	int	button = (int)SvIV(ST(0));
	BOOL	RETVAL;
	dXSTARG;
#line 1092 "GUITest.xs"
	RETVAL = (BOOL)XTestFakeButtonEvent(TheXDisplay, button, True, EventSendDelay);
	XFlush(TheXDisplay);
#line 1190 "GUITest.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_X11__GUITest_ReleaseMouseButton); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_ReleaseMouseButton)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::ReleaseMouseButton", "button");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	int	button = (int)SvIV(ST(0));
	BOOL	RETVAL;
	dXSTARG;
#line 1117 "GUITest.xs"
	RETVAL = (BOOL)XTestFakeButtonEvent(TheXDisplay, button, False, EventSendDelay);
	XFlush(TheXDisplay);
#line 1215 "GUITest.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_X11__GUITest_SendKeys); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_SendKeys)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::SendKeys", "keys");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	char *	keys = (char *)SvPV_nolen(ST(0));
	BOOL	RETVAL;
	dXSTARG;
#line 1249 "GUITest.xs"
	RETVAL = SendKeysImp(keys);
#line 1239 "GUITest.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_X11__GUITest_PressKey); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_PressKey)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::PressKey", "key");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	char *	key = (char *)SvPV_nolen(ST(0));
#line 1288 "GUITest.xs"
	KeySym sym = 0;
#line 1261 "GUITest.c"
	BOOL	RETVAL;
	dXSTARG;
#line 1290 "GUITest.xs"
	RETVAL = GetKeySym(key, &sym);
	if (RETVAL) {
		RETVAL = PressKeyImp(sym);
	}
#line 1269 "GUITest.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_X11__GUITest_ReleaseKey); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_ReleaseKey)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::ReleaseKey", "key");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	char *	key = (char *)SvPV_nolen(ST(0));
#line 1319 "GUITest.xs"
	KeySym sym = 0;
#line 1291 "GUITest.c"
	BOOL	RETVAL;
	dXSTARG;
#line 1321 "GUITest.xs"
	RETVAL = GetKeySym(key, &sym);
	if (RETVAL) {
		RETVAL = ReleaseKeyImp(sym);
	}
#line 1299 "GUITest.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_X11__GUITest_PressReleaseKey); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_PressReleaseKey)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::PressReleaseKey", "key");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	char *	key = (char *)SvPV_nolen(ST(0));
#line 1352 "GUITest.xs"
	KeySym sym = 0;
#line 1321 "GUITest.c"
	BOOL	RETVAL;
	dXSTARG;
#line 1354 "GUITest.xs"
	RETVAL = GetKeySym(key, &sym);
	if (RETVAL) {
		RETVAL = PressReleaseKeyImp(sym);
	}
#line 1329 "GUITest.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_X11__GUITest_IsKeyPressed); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_IsKeyPressed)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::IsKeyPressed", "key");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	char *	key = (char *)SvPV_nolen(ST(0));
#line 1386 "GUITest.xs"
	int pos = 0;
	KeySym sym = 0;
	KeyCode kc = 0, skc = 0;
	BOOL keyon = FALSE, shifton = FALSE;
	char keys_return[KEYMAP_VECTOR_SIZE] = "";
#line 1355 "GUITest.c"
	BOOL	RETVAL;
	dXSTARG;
#line 1392 "GUITest.xs"
	if (key && GetKeySym(key, &sym)) {
		kc = GetKeycodeFromKeysym(TheXDisplay, sym);
		skc = GetKeycodeFromKeysym(TheXDisplay, XK_Shift_L); 
		XQueryKeymap(TheXDisplay, keys_return);
		for (pos = 0; pos < (KEYMAP_VECTOR_SIZE * KEYMAP_BIT_COUNT); pos++) {
			/* For the derived keycode, are we at the correct bit position for it? */
			if (kc == pos) {
				/* Check the bit at this position to determine the state of the key */
				if ( keys_return[pos / KEYMAP_BIT_COUNT] & (1 << (pos % KEYMAP_BIT_COUNT)) ) {
					/* Bit On, so key is pressed */
					keyon = TRUE;
				}
			}
			/* For the shift keycode, ... */
			if (skc == pos) {
				/* Check the bit at this position to determine the state of the shift key */
				if ( keys_return[pos / KEYMAP_BIT_COUNT] & (1 << (pos % KEYMAP_BIT_COUNT)) ) {
					/* Bit On, so shift is pressed */
					shifton = TRUE;
				}
			}
		} /* for (pos = 0; pos < (KEYMAP_VECTOR_SIZE * KEYMAP_BIT_COUNT); pos++) { */
	} /* if (key && GetKeySym(key, &sym)) { */

	/* Determine result */
	if (keyon) {
		/* Key is on, so use its keysym to determine if shift modifier needs to be verified also */
		if (IsShiftNeeded(sym)) {
			RETVAL = (shifton);
		} else {
			RETVAL = (!shifton);	
		}
	} else {
		/* Key not on, so it is not pressed */
		RETVAL = FALSE;
	}
#line 1395 "GUITest.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_X11__GUITest_IsMouseButtonPressed); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_IsMouseButtonPressed)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::IsMouseButtonPressed", "button");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	int	button = (int)SvIV(ST(0));
#line 1455 "GUITest.xs"
	Window root = 0, child = 0;
	int root_x = 0, root_y = 0;
	int win_x = 0, win_y = 0;
	UINT mask = 0;
#line 1420 "GUITest.c"
	BOOL	RETVAL;
	dXSTARG;
#line 1460 "GUITest.xs"
	XQueryPointer(TheXDisplay, RootWindow(TheXDisplay, TheScreen),
				  &root, &child, &root_x, &root_y,
				  &win_x, &win_y, &mask);
	switch (button) {
	case Button1:
		RETVAL = (mask & Button1Mask);
		break;
	case Button2:
		RETVAL = (mask & Button2Mask);
		break;
	case Button3:
		RETVAL = (mask & Button3Mask);
		break;
	case Button4:
		RETVAL = (mask & Button4Mask);
		break;
	case Button5:
		RETVAL = (mask & Button5Mask);
		break;
	default:
		RETVAL = FALSE;
		break;
	};
#line 1447 "GUITest.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_X11__GUITest_IsWindow); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_IsWindow)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::IsWindow", "win");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Window	win = (Window)SvUV(ST(0));
	BOOL	RETVAL;
	dXSTARG;
#line 1503 "GUITest.xs"
	RETVAL = IsWindowImp(win);
#line 1471 "GUITest.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_X11__GUITest_IsWindowViewable); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_IsWindowViewable)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::IsWindowViewable", "win");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Window	win = (Window)SvUV(ST(0));
#line 1523 "GUITest.xs"
	XWindowAttributes wattrs = {0};
#line 1493 "GUITest.c"
	BOOL	RETVAL;
	dXSTARG;
#line 1525 "GUITest.xs"
	OldErrorHandler = XSetErrorHandler(IgnoreBadWindow);
	if (!XGetWindowAttributes(TheXDisplay, win, &wattrs)) {
		RETVAL = FALSE;
	} else { 
		RETVAL = (wattrs.map_state == IsViewable);
	}
	XSetErrorHandler(OldErrorHandler);
#line 1504 "GUITest.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_X11__GUITest_MoveWindow); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_MoveWindow)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::MoveWindow", "win, x, y");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Window	win = (Window)SvUV(ST(0));
	int	x = (int)SvIV(ST(1));
	int	y = (int)SvIV(ST(2));
	BOOL	RETVAL;
	dXSTARG;
#line 1554 "GUITest.xs"
	OldErrorHandler = XSetErrorHandler(IgnoreBadWindow);
	RETVAL = XMoveWindow(TheXDisplay, win, x, y);
	XSync(TheXDisplay, False);
	XSetErrorHandler(OldErrorHandler);
#line 1533 "GUITest.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_X11__GUITest_ResizeWindow); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_ResizeWindow)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::ResizeWindow", "win, w, h");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Window	win = (Window)SvUV(ST(0));
	int	w = (int)SvIV(ST(1));
	int	h = (int)SvIV(ST(2));
	BOOL	RETVAL;
	dXSTARG;
#line 1580 "GUITest.xs"
	OldErrorHandler = XSetErrorHandler(IgnoreBadWindow);
	RETVAL = XResizeWindow(TheXDisplay, win, w, h);
	XSync(TheXDisplay, False);
	XSetErrorHandler(OldErrorHandler);
#line 1562 "GUITest.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_X11__GUITest_IconifyWindow); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_IconifyWindow)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::IconifyWindow", "win");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Window	win = (Window)SvUV(ST(0));
#line 1604 "GUITest.xs"
	XWindowAttributes wattrs = {0};
	int scr_num;
#line 1585 "GUITest.c"
	BOOL	RETVAL;
	dXSTARG;
#line 1607 "GUITest.xs"
	OldErrorHandler = XSetErrorHandler(IgnoreBadWindow);
	if (XGetWindowAttributes(TheXDisplay, win, &wattrs)) {
		for (scr_num = ScreenCount(TheXDisplay) - 1;
		     scr_num >= 0 ; --scr_num)
		{
			if ( wattrs.screen
			  == ScreenOfDisplay(TheXDisplay, scr_num))
			{
				break;
			}
			assert(0 != scr_num);
			/* There is something really wrong with the Xlib data
			   structures, if this "assert" fails. */
		}
		RETVAL = XIconifyWindow(TheXDisplay, win, scr_num);
		XSync(TheXDisplay, False);
	} else {
		RETVAL = (BOOL) 0;
	}
	XSetErrorHandler(OldErrorHandler);
#line 1609 "GUITest.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_X11__GUITest_UnIconifyWindow); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_UnIconifyWindow)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::UnIconifyWindow", "win");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Window	win = (Window)SvUV(ST(0));
	BOOL	RETVAL;
	dXSTARG;
#line 1647 "GUITest.xs"
	OldErrorHandler = XSetErrorHandler(IgnoreBadWindow);
	RETVAL = XMapWindow(TheXDisplay, win);
	XSync(TheXDisplay, False);
	XSetErrorHandler(OldErrorHandler);
#line 1636 "GUITest.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_X11__GUITest_RaiseWindow); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_RaiseWindow)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::RaiseWindow", "win");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Window	win = (Window)SvUV(ST(0));
	BOOL	RETVAL;
	dXSTARG;
#line 1672 "GUITest.xs"
	OldErrorHandler = XSetErrorHandler(IgnoreBadWindow);
	RETVAL = XRaiseWindow(TheXDisplay, win);
	XSync(TheXDisplay, False);
	XSetErrorHandler(OldErrorHandler);
#line 1663 "GUITest.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_X11__GUITest_LowerWindow); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_LowerWindow)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::LowerWindow", "win");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Window	win = (Window)SvUV(ST(0));
	BOOL	RETVAL;
	dXSTARG;
#line 1697 "GUITest.xs"
	OldErrorHandler = XSetErrorHandler(IgnoreBadWindow);
	RETVAL = XLowerWindow(TheXDisplay, win);
	XSync(TheXDisplay, False);
	XSetErrorHandler(OldErrorHandler);
#line 1690 "GUITest.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_X11__GUITest_GetInputFocus); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_GetInputFocus)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::GetInputFocus", "");
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 1718 "GUITest.xs"
	Window focus = 0;
	int revert = 0;
#line 1712 "GUITest.c"
	Window	RETVAL;
	dXSTARG;
#line 1721 "GUITest.xs"
	XGetInputFocus(TheXDisplay, &focus, &revert);
	RETVAL = focus;
#line 1718 "GUITest.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_X11__GUITest_SetInputFocus); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_SetInputFocus)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::SetInputFocus", "win");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Window	win = (Window)SvUV(ST(0));
#line 1743 "GUITest.xs"
	Window focus = 0;
	int revert = 0;
#line 1741 "GUITest.c"
	BOOL	RETVAL;
	dXSTARG;
#line 1746 "GUITest.xs"
	OldErrorHandler = XSetErrorHandler(IgnoreBadWindow);
	/* Note: Per function man page, there is no effect if the time parameter
	 *  	 of this call isn't accurate.  Will use CurrentTime.  Also, it
	 *		 appears that we can't trust its return value. */
	XSetInputFocus(TheXDisplay, win, RevertToParent, CurrentTime);
	XSync(TheXDisplay, False);
	XSetErrorHandler(OldErrorHandler);
	/* Verify that the window now has focus.  Used to determine return value */
	XGetInputFocus(TheXDisplay, &focus, &revert);
	RETVAL = (focus == win);
#line 1755 "GUITest.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_X11__GUITest_GetWindowPos); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_GetWindowPos)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::GetWindowPos", "win");
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Window	win = (Window)SvUV(ST(0));
#line 1779 "GUITest.xs"
	XWindowAttributes wattrs = {0};
	Window child = 0;
	int num_ret = 0, x = 0, y = 0, scr_num;
#line 1781 "GUITest.c"
#line 1783 "GUITest.xs"
	OldErrorHandler = XSetErrorHandler(IgnoreBadWindow);
	if (XGetWindowAttributes(TheXDisplay, win, &wattrs)) {
		XTranslateCoordinates(TheXDisplay, win, wattrs.root,
			0 - wattrs.border_width, 0 - wattrs.border_width,
			&x, &y, &child);
		EXTEND(SP, 6);
		PUSHs( sv_2mortal(newSViv((IV)x)) );
		PUSHs( sv_2mortal(newSViv((IV)y)) );
		PUSHs( sv_2mortal(newSViv((IV)wattrs.width)) );
		PUSHs( sv_2mortal(newSViv((IV)wattrs.height)) );
		PUSHs( sv_2mortal(newSViv((IV)wattrs.border_width)) );
		for (scr_num = ScreenCount(TheXDisplay) - 1;
		     scr_num >= 0 ; --scr_num)
		{
			if ( wattrs.screen
			  == ScreenOfDisplay(TheXDisplay, scr_num))
			{
				break;
			}
			assert(0 != scr_num);
			/* There is something really wrong with the Xlib data
			   structures, if this "assert" fails. */
		}
		PUSHs( sv_2mortal(newSViv((IV)scr_num)) );
		num_ret = 6;
	}
	XSetErrorHandler(OldErrorHandler);
	XSRETURN(num_ret);
#line 1811 "GUITest.c"
	PUTBACK;
	return;
    }
}


XS(XS_X11__GUITest_GetParentWindow); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_GetParentWindow)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::GetParentWindow", "win");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Window	win = (Window)SvUV(ST(0));
#line 1829 "GUITest.xs"
	Window parent = 0, *children = NULL, root = 0;
	UINT childcount = 0; 
#line 1834 "GUITest.c"
	Window	RETVAL;
	dXSTARG;
#line 1832 "GUITest.xs"
	RETVAL = 0;
	if (XQueryTree(TheXDisplay, win, &root, &parent, &children, &childcount)) {
		XFree(children);
		RETVAL = parent;		
	}
#line 1843 "GUITest.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_X11__GUITest_GetScreenRes); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_GetScreenRes)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 0 || items > 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::GetScreenRes", "scr_num = NO_INIT");
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	int	scr_num;
#line 1859 "GUITest.xs"
	int x = 0, y = 0, num_ret = 0;
#line 1867 "GUITest.c"

	if (items >= 1) {
	    scr_num = (int)SvIV(ST(0));
	}
#line 1861 "GUITest.xs"
	if (0 == items)
		scr_num = TheScreen;
	if (scr_num >= 0 && scr_num < ScreenCount(TheXDisplay)) {
		x = DisplayWidth(TheXDisplay, scr_num);
		y = DisplayHeight(TheXDisplay, scr_num);
		EXTEND(SP, 2);
		PUSHs( sv_2mortal(newSViv((IV)x)) );
		PUSHs( sv_2mortal(newSViv((IV)y)) );
		num_ret = 2;
	}
	XSRETURN(num_ret);
#line 1884 "GUITest.c"
	PUTBACK;
	return;
    }
}


XS(XS_X11__GUITest_GetScreenDepth); /* prototype to pass -Wmissing-prototypes */
XS(XS_X11__GUITest_GetScreenDepth)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 0 || items > 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "X11::GUITest::GetScreenDepth", "scr_num = NO_INIT");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	int	scr_num;
	int	RETVAL;
	dXSTARG;

	if (items >= 1) {
	    scr_num = (int)SvIV(ST(0));
	}
#line 1895 "GUITest.xs"
	if (0 == items)
		scr_num = TheScreen;
	if (scr_num >= 0 && scr_num < ScreenCount(TheXDisplay)) {
		RETVAL = DefaultDepth(TheXDisplay, scr_num);
	} else {
		RETVAL = -1;
	}
#line 1918 "GUITest.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_X11__GUITest); /* prototype to pass -Wmissing-prototypes */
XS(boot_X11__GUITest)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    char* file = __FILE__;

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        newXS("X11::GUITest::InitGUITest", XS_X11__GUITest_InitGUITest, file);
        newXS("X11::GUITest::DeInitGUITest", XS_X11__GUITest_DeInitGUITest, file);
        newXS("X11::GUITest::DefaultScreen", XS_X11__GUITest_DefaultScreen, file);
        newXS("X11::GUITest::ScreenCount", XS_X11__GUITest_ScreenCount, file);
        newXS("X11::GUITest::SetEventSendDelay", XS_X11__GUITest_SetEventSendDelay, file);
        newXS("X11::GUITest::GetEventSendDelay", XS_X11__GUITest_GetEventSendDelay, file);
        newXS("X11::GUITest::SetKeySendDelay", XS_X11__GUITest_SetKeySendDelay, file);
        newXS("X11::GUITest::GetKeySendDelay", XS_X11__GUITest_GetKeySendDelay, file);
        newXS("X11::GUITest::GetWindowName", XS_X11__GUITest_GetWindowName, file);
        newXS("X11::GUITest::SetWindowName", XS_X11__GUITest_SetWindowName, file);
        newXS("X11::GUITest::GetRootWindow", XS_X11__GUITest_GetRootWindow, file);
        newXS("X11::GUITest::GetChildWindows", XS_X11__GUITest_GetChildWindows, file);
        newXS("X11::GUITest::MoveMouseAbs", XS_X11__GUITest_MoveMouseAbs, file);
        newXS("X11::GUITest::GetMousePos", XS_X11__GUITest_GetMousePos, file);
        newXS("X11::GUITest::PressMouseButton", XS_X11__GUITest_PressMouseButton, file);
        newXS("X11::GUITest::ReleaseMouseButton", XS_X11__GUITest_ReleaseMouseButton, file);
        newXS("X11::GUITest::SendKeys", XS_X11__GUITest_SendKeys, file);
        newXS("X11::GUITest::PressKey", XS_X11__GUITest_PressKey, file);
        newXS("X11::GUITest::ReleaseKey", XS_X11__GUITest_ReleaseKey, file);
        newXS("X11::GUITest::PressReleaseKey", XS_X11__GUITest_PressReleaseKey, file);
        newXS("X11::GUITest::IsKeyPressed", XS_X11__GUITest_IsKeyPressed, file);
        newXS("X11::GUITest::IsMouseButtonPressed", XS_X11__GUITest_IsMouseButtonPressed, file);
        newXS("X11::GUITest::IsWindow", XS_X11__GUITest_IsWindow, file);
        newXS("X11::GUITest::IsWindowViewable", XS_X11__GUITest_IsWindowViewable, file);
        newXS("X11::GUITest::MoveWindow", XS_X11__GUITest_MoveWindow, file);
        newXS("X11::GUITest::ResizeWindow", XS_X11__GUITest_ResizeWindow, file);
        newXS("X11::GUITest::IconifyWindow", XS_X11__GUITest_IconifyWindow, file);
        newXS("X11::GUITest::UnIconifyWindow", XS_X11__GUITest_UnIconifyWindow, file);
        newXS("X11::GUITest::RaiseWindow", XS_X11__GUITest_RaiseWindow, file);
        newXS("X11::GUITest::LowerWindow", XS_X11__GUITest_LowerWindow, file);
        newXS("X11::GUITest::GetInputFocus", XS_X11__GUITest_GetInputFocus, file);
        newXS("X11::GUITest::SetInputFocus", XS_X11__GUITest_SetInputFocus, file);
        newXS("X11::GUITest::GetWindowPos", XS_X11__GUITest_GetWindowPos, file);
        newXS("X11::GUITest::GetParentWindow", XS_X11__GUITest_GetParentWindow, file);
        newXS("X11::GUITest::GetScreenRes", XS_X11__GUITest_GetScreenRes, file);
        newXS("X11::GUITest::GetScreenDepth", XS_X11__GUITest_GetScreenDepth, file);
    if (PL_unitcheckav)
         call_list(PL_scopestack_ix, PL_unitcheckav);
    XSRETURN_YES;
}

